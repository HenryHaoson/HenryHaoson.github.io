---
layout: post
title: 类初始化的时机
date: 2017-8-5
categories: blog
tags: [JVM]
description: 继续在看《深入理解JVM》,看了这类初始化 的时机之后终于了解的一些面试题背后的原理。
---

# 类初始化时机

jvm 虚拟机**严格**规定**有且只有**5 种情况必须立即对类进行初始化。

-   遇到 new、getstatic、putstatic、invokestatic 这 4 条字节码指令时，如果类还未初始化，则要先初始化该类。
-   使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类还未初始化，则需要先初始化该类。
-   在初始化一个类的时候，如果该类的父类还未初始化，则需要先初始化该类的父类。
-   当虚拟机启动的时候，用户需要指定执行的一个主类（包含 main()函数的那个类），虚拟机会先初始化这个类。
-   当使用 jdk1.7 动态语言支持的时候，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有初始化，那么先要初始化该类。
-

Tips

-   只有直接定义被使用的静态字段的类才会被初始化。比如说字类调用父类中设置的静态字段，那么会初始化父类。而子类不会初始化，但是子类会不会加载和验证取决于各个虚拟机实现，JVM 在这方面没有做严格规定。
-   通过数组定义来引用类，不会触发此类的初始化。

```
//不会触发SuperClass类的初始化。
SuperClass[] sca= new SuperClass[10];
```

其实这段代码会触发另一个类的初始化，只不过这个类是由虚拟机自动生成的，直接继承于 java.lang.Object 类的子类，而且是由 newarray 指令触发的。这个类代表元素类型是 SuperClass 的一维数组，数组中应有的方法（用户可直接使用的只有被修饰为 public 的 length 属性和 clone()方法）都在这个类里面实现。

-   静态常量，

```
public class ConstClass {
    static {
        System.out.println("ConstClass init!");
    }

    public static final String HELLOWORLD = "hello world";
}


public class NogInitialization {

    public static void main(String[] args ){
        System.out.println(ConstClass.HELLOWORLD);
    }
}
```

输出结果没有输出`ConstClass init！`，原因是虽然调用了 ConstClass 中的常量，但是在编译的时候通过常量传播优化，已经将常量的值"hello word"存储到 NogInitialization 类的常量池中了。以后 NogInitialization 对常量 ConstClass.HELLOWORLD 的引用都会转换成对自身常量池的引用。
