---
layout: post
title: 类初始化的时机
date: 2017-8-5
categories: blog
tags: [jvm]
description: 继续在看《深入理解JVM》,看了这类初始化 的时机之后终于了解的一些面试题背后的原理。

---
# 类初始化时机
jvm虚拟机**严格**规定**有且只有**5种情况必须立即对类进行初始化。

- 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类还未初始化，则要先初始化该类。
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类还未初始化，则需要先初始化该类。
- 在初始化一个类的时候，如果该类的父类还未初始化，则需要先初始化该类的父类。
- 当虚拟机启动的时候，用户需要指定执行的一个主类（包含main()函数的那个类），虚拟机会先初始化这个类。
- 当使用jdk1.7动态语言支持的时候，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有初始化，那么先要初始化该类。
- 

Tips
- 只有直接定义被使用的静态字段的类才会被初始化。比如说字类调用父类中设置的静态字段，那么会初始化父类。而子类不会初始化，但是子类会不会加载和验证取决于各个虚拟机实现，JVM在这方面没有做严格规定。
- 通过数组定义来引用类，不会触发此类的初始化。
```
//不会触发SuperClass类的初始化。
SuperClass[] sca= new SuperClass[10];
```
其实这段代码会触发另一个类的初始化，只不过这个类是由虚拟机自动生成的，直接继承于java.lang.Object类的子类，而且是由newarray指令触发的。这个类代表元素类型是SuperClass的一维数组，数组中应有的方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都在这个类里面实现。
- 静态常量，
```
public class ConstClass {
    static {
        System.out.println("ConstClass init!");
    }
    
    public static final String HELLOWORLD = "hello world";
}


public class NogInitialization {
    
    public static void main(String[] args ){
        System.out.println(ConstClass.HELLOWORLD);
    }
}
```

输出结果没有输出`ConstClass init！`，原因是虽然调用了ConstClass中的常量，但是在编译的时候通过常量传播优化，已经将常量的值"hello word"存储到NogInitialization类的常量池中了。以后NogInitialization对常量ConstClass.HELLOWORLD的引用都会转换成对自身常量池的引用。 