---
layout: post
title: JVM运行时数据区域
date: 2017-5-10
categories: blog
tags: [java]
description: JVM运行时数据区域

---
神图压阵：
![Paste_Image.png](http://upload-images.jianshu.io/upload_images/3351492-d0a615a85b48e4f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
###JVM运行态数据
####程序计数器
>程序计数器（Program Counter Register),是一块较小的内存空间，可以看作是当前线程所执行的字节码的型号指示器。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，所以在某一时刻，处理器只会执行一条线程中的指令，因此每条线程都必须有一个独立的程序计数器，成为"线程私有"的内存。
 如果线程执行的是java方法，那么程序计数器记录的就是正在执行的虚拟机字节码指令的地址，但是如果执行的是native方法，那么程序计数器值为空（undefined）。程序计数器内存空间是唯一一个在java虚拟机规范中没有规范任何OutOfMemoryError情况的区域。

#### JVM虚拟界栈
>Java虚拟机栈（Java Virtual Machine Stacks）同样是线程私有的。生命周期和线程一样。Java虚拟机栈是用来描述Java方法的内存模型，每当Java方法执行的时候都会创建一个栈帧（Stack Frame）用来存储局部变量表，方法出口，操作数栈等信息。方法从调用到执行完毕的过程就是入栈到出栈的过程。

#### JVM本地方法栈
>本地方法栈（Native Method Stack）和JVM虚拟机栈功能类似，这里是用来描述Native方法，JVM并没有对本地方法栈做出强制规范。和虚拟机栈一样，会爆出StackOverflowError和OutOfMemoryError异常。

#### Java堆
>Java堆（Java Heap）一般来说是java虚拟机所管理的内存中最大的一块。Java堆被所有线程所共享。这个内存块创建的唯一目的就是存放对象实例，几乎所有的对象实例都是在这儿分配内存的。
这里是GC的只要区域。

#### 方法区
>方法区（Method Area)也是线程共享的。用于存储虚拟机加载的类的信息，常量，静态变量，即时编译后的代码等数据。JVM虚拟没有对方法区的回收做规定，可以选择回收（像HotSpot将方法区划分为永久代），也可以选择不回收。

#### 运行时常量池
>运行时常量池（RunTime Constant Pool）是属于方法区的一部分，常量池用于存放编译期生成的各种字面量和符号应用，这些东西在类加载的时候进入方法区的运行时常量池中存放。运行时常量池的一大特点就是具有动态性，运行期间也可以将新的常量放入运行时常量池中。被用的比较多的就是String.intern()。